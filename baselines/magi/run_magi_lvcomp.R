#!/usr/bin/env Rscript
# MAGI baseline: Lotka-Volterra Competition (off-diagonal alpha)
#
# Reads data and true parameters generated by Julia's generate_data.jl.
#
# Usage:
#   Rscript baselines/magi/run_magi_lvcomp.R                          # all K, all seeds
#   Rscript baselines/magi/run_magi_lvcomp.R --K 5 --seed 42          # single run
#   Rscript baselines/magi/run_magi_lvcomp.R --K 2,5 --N 40 --niter 20000

library(magi)
library(coda)
library(jsonlite)

# Source custom model definitions
get_script_dir <- function() {
  args <- commandArgs(trailingOnly = FALSE)
  file_arg <- grep("--file=", args, value = TRUE)
  if (length(file_arg) > 0) {
    return(dirname(normalizePath(sub("--file=", "", file_arg))))
  }
  # Fallback: try sys.frame (works in source() context)
  tryCatch(dirname(sys.frame(1)$ofile), error = function(e) ".")
}
script_dir <- get_script_dir()
source(file.path(script_dir, "models.R"))

# ── Configuration ──────────────────────────────────────────────────────────

args <- commandArgs(trailingOnly = TRUE)

parse_arg <- function(flag, default) {
  idx <- which(args == flag)
  if (length(idx) > 0 && idx < length(args)) return(args[idx + 1])
  return(default)
}

K_values   <- as.integer(strsplit(parse_arg("--K", "2,5,10,20"), ",")[[1]])
N_val      <- as.integer(parse_arg("--N", "40"))
seeds      <- as.integer(strsplit(parse_arg("--seed", "42,123,456,789,1234,2345,3456,4567,5678,6789"), ",")[[1]])
niter_hmc  <- as.integer(parse_arg("--niter", "20000"))
nsteps_hmc <- as.integer(parse_arg("--nsteps", "200"))
burnin     <- as.numeric(parse_arg("--burnin", "0.5"))

data_dir    <- file.path(script_dir, "..", "data")
results_dir <- file.path(script_dir, "results")
dir.create(results_dir, showWarnings = FALSE, recursive = TRUE)

# ── Run ────────────────────────────────────────────────────────────────────

results_all <- data.frame()

for (K in K_values) {
  n_params <- K * (K - 1)

  # Load true parameters from JSON
  params_file <- file.path(data_dir, sprintf("lvc_K%d_params.json", K))
  if (!file.exists(params_file)) {
    cat(sprintf("SKIP: %s not found. Run generate_data.jl --ode LVC --K %d first.\n",
                params_file, K))
    next
  }
  params_json <- fromJSON(params_file)
  r_true  <- params_json$r_true
  Ks_true <- params_json$Ks_true
  diag_alpha <- params_json$diag_alpha
  theta_true <- params_json$alpha_offdiag_true

  # Build MAGI model
  lvc_model <- make_lvc_model(K, r_true, Ks_true, diag_alpha)

  for (seed in seeds) {
    # Load data
    fname <- file.path(data_dir, sprintf("lvc_K%d_N%d_seed%d.csv", K, N_val, seed))
    if (!file.exists(fname)) {
      cat(sprintf("SKIP: %s not found.\n", fname))
      next
    }
    dat <- read.csv(fname)

    # Format for MAGI: data.frame with "time" column + component columns
    y_obs <- data.frame(time = dat$time)
    for (i in 1:K) {
      y_obs[[paste0("x", i)]] <- dat[[paste0("x", i)]]
    }

    # Discretization: insert intermediate points
    y_input <- setDiscretization(y_obs, level = 1)

    # Run MAGI
    cat(sprintf("LVC K=%d: N=%d, seed=%d, n_params=%d, niter=%d ...\n",
                K, N_val, seed, n_params, niter_hmc))
    set.seed(seed)
    t_start <- proc.time()
    result <- tryCatch({
      MagiSolver(
        y = y_input,
        odeModel = lvc_model,
        control = list(
          niterHmc = niter_hmc,
          nstepsHmc = nsteps_hmc,
          burninRatio = burnin
        )
      )
    }, error = function(e) {
      cat(sprintf("  ERROR: %s\n", conditionMessage(e)))
      return(NULL)
    })
    t_elapsed <- (proc.time() - t_start)["elapsed"]

    if (is.null(result)) {
      # Record failed run
      row <- data.frame(
        ode = sprintf("LVC_K%d", K), method = "MAGI",
        K = K, n_params = n_params, N = N_val, seed = seed,
        rmsd = NA, ess_mean = NA, time_sec = as.numeric(t_elapsed),
        ess_per_sec = NA
      )
      results_all <- rbind(results_all, row)
      next
    }

    # Extract posterior samples (post burn-in)
    theta_samples <- result$theta  # matrix: n_samples x n_params

    # Posterior mean
    theta_mean <- colMeans(theta_samples)

    # RMSD
    rmsd <- sqrt(mean((theta_mean - theta_true)^2))

    # ESS (using coda)
    ess_vals <- effectiveSize(theta_samples)
    ess_mean <- mean(ess_vals)
    ess_per_sec <- ess_mean / as.numeric(t_elapsed)

    cat(sprintf("  RMSD=%.4f, ESS_mean=%.1f, time=%.1fs, ESS/sec=%.2f\n",
                rmsd, ess_mean, t_elapsed, ess_per_sec))

    # Save summary
    row <- data.frame(
      ode = sprintf("LVC_K%d", K), method = "MAGI",
      K = K, n_params = n_params, N = N_val, seed = seed,
      rmsd = rmsd, ess_mean = ess_mean,
      time_sec = as.numeric(t_elapsed), ess_per_sec = ess_per_sec
    )
    # Add per-parameter metrics
    for (i in seq_along(theta_mean)) {
      row[[paste0("theta_", i, "_mean")]] <- theta_mean[i]
      if (i <= length(theta_true)) {
        row[[paste0("theta_", i, "_true")]] <- theta_true[i]
      }
      row[[paste0("ess_", i)]] <- ess_vals[i]
    }
    results_all <- rbind(results_all, row)

    # Save full posterior samples
    samples_df <- as.data.frame(theta_samples)
    colnames(samples_df) <- params_json$param_names
    write.csv(samples_df,
              file.path(results_dir, sprintf("lvc_K%d_N%d_seed%d_samples.csv", K, N_val, seed)),
              row.names = FALSE)
  }
}

# Save aggregated results
write.csv(results_all,
          file.path(results_dir, "lvc_summary.csv"),
          row.names = FALSE)
cat("Results saved to", file.path(results_dir, "lvc_summary.csv"), "\n")
